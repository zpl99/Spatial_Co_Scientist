# Generated from GeoAnQu.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3P")
        buf.write("\u0292\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\3\2\3\2\3\2\3\2\5\2Q\n\2\3\2\3\2\3\2\5\2V\n\2\3\2\5")
        buf.write("\2Y\n\2\5\2[\n\2\3\2\3\2\5\2_\n\2\3\2\5\2b\n\2\3\2\5\2")
        buf.write("e\n\2\5\2g\n\2\3\2\3\2\3\2\5\2l\n\2\7\2n\n\2\f\2\16\2")
        buf.write("q\13\2\3\2\5\2t\n\2\3\2\3\2\3\2\5\2y\n\2\5\2{\n\2\3\2")
        buf.write("\5\2~\n\2\3\2\5\2\u0081\n\2\3\2\3\2\5\2\u0085\n\2\3\2")
        buf.write("\5\2\u0088\n\2\3\2\5\2\u008b\n\2\3\2\3\2\5\2\u008f\n\2")
        buf.write("\6\2\u0091\n\2\r\2\16\2\u0092\7\2\u0095\n\2\f\2\16\2\u0098")
        buf.write("\13\2\3\2\5\2\u009b\n\2\3\2\3\2\5\2\u009f\n\2\3\2\5\2")
        buf.write("\u00a2\n\2\5\2\u00a4\n\2\3\3\3\3\3\4\3\4\3\4\3\4\3\4\5")
        buf.write("\4\u00ad\n\4\3\4\5\4\u00b0\n\4\3\4\3\4\5\4\u00b4\n\4\6")
        buf.write("\4\u00b6\n\4\r\4\16\4\u00b7\3\4\3\4\5\4\u00bc\n\4\3\4")
        buf.write("\5\4\u00bf\n\4\3\4\5\4\u00c2\n\4\3\4\3\4\5\4\u00c6\n\4")
        buf.write("\7\4\u00c8\n\4\f\4\16\4\u00cb\13\4\3\4\5\4\u00ce\n\4\3")
        buf.write("\4\5\4\u00d1\n\4\3\4\3\4\5\4\u00d5\n\4\3\4\5\4\u00d8\n")
        buf.write("\4\3\4\7\4\u00db\n\4\f\4\16\4\u00de\13\4\3\4\5\4\u00e1")
        buf.write("\n\4\3\4\7\4\u00e4\n\4\f\4\16\4\u00e7\13\4\3\4\5\4\u00ea")
        buf.write("\n\4\3\4\7\4\u00ed\n\4\f\4\16\4\u00f0\13\4\3\4\3\4\3\4")
        buf.write("\3\4\5\4\u00f6\n\4\3\5\3\5\3\5\3\6\3\6\5\6\u00fd\n\6\3")
        buf.write("\6\5\6\u0100\n\6\3\6\3\6\5\6\u0104\n\6\3\6\3\6\5\6\u0108")
        buf.write("\n\6\6\6\u010a\n\6\r\6\16\6\u010b\3\6\3\6\5\6\u0110\n")
        buf.write("\6\5\6\u0112\n\6\3\6\5\6\u0115\n\6\3\7\3\7\3\b\3\b\5\b")
        buf.write("\u011b\n\b\3\b\3\b\3\b\5\b\u0120\n\b\3\b\3\b\5\b\u0124")
        buf.write("\n\b\3\b\5\b\u0127\n\b\3\t\3\t\3\t\5\t\u012c\n\t\3\t\3")
        buf.write("\t\3\n\3\n\5\n\u0132\n\n\3\n\3\n\5\n\u0136\n\n\3\n\3\n")
        buf.write("\3\n\3\n\3\n\5\n\u013d\n\n\3\n\5\n\u0140\n\n\3\n\5\n\u0143")
        buf.write("\n\n\3\n\3\n\5\n\u0147\n\n\3\n\5\n\u014a\n\n\3\n\5\n\u014d")
        buf.write("\n\n\3\n\5\n\u0150\n\n\3\n\5\n\u0153\n\n\3\n\3\n\3\n\5")
        buf.write("\n\u0158\n\n\3\n\5\n\u015b\n\n\3\n\3\n\5\n\u015f\n\n\3")
        buf.write("\n\3\n\3\n\3\n\3\n\7\n\u0166\n\n\f\n\16\n\u0169\13\n\5")
        buf.write("\n\u016b\n\n\3\n\5\n\u016e\n\n\3\n\3\n\3\n\3\n\5\n\u0174")
        buf.write("\n\n\3\n\5\n\u0177\n\n\3\n\3\n\5\n\u017b\n\n\3\n\5\n\u017e")
        buf.write("\n\n\3\n\3\n\3\n\5\n\u0183\n\n\5\n\u0185\n\n\3\n\3\n\5")
        buf.write("\n\u0189\n\n\3\13\5\13\u018c\n\13\3\13\3\13\3\13\5\13")
        buf.write("\u0191\n\13\3\13\5\13\u0194\n\13\3\f\3\f\5\f\u0198\n\f")
        buf.write("\3\f\5\f\u019b\n\f\6\f\u019d\n\f\r\f\16\f\u019e\3\f\5")
        buf.write("\f\u01a2\n\f\3\f\3\f\5\f\u01a6\n\f\3\f\3\f\5\f\u01aa\n")
        buf.write("\f\7\f\u01ac\n\f\f\f\16\f\u01af\13\f\3\r\3\r\5\r\u01b3")
        buf.write("\n\r\3\r\5\r\u01b6\n\r\6\r\u01b8\n\r\r\r\16\r\u01b9\3")
        buf.write("\r\5\r\u01bd\n\r\3\r\5\r\u01c0\n\r\3\r\3\r\5\r\u01c4\n")
        buf.write("\r\3\r\3\r\5\r\u01c8\n\r\3\16\5\16\u01cb\n\16\3\16\3\16")
        buf.write("\5\16\u01cf\n\16\3\16\5\16\u01d2\n\16\3\16\5\16\u01d5")
        buf.write("\n\16\3\16\3\16\3\16\6\16\u01da\n\16\r\16\16\16\u01db")
        buf.write("\3\17\5\17\u01df\n\17\3\17\3\17\5\17\u01e3\n\17\3\17\3")
        buf.write("\17\5\17\u01e7\n\17\3\17\5\17\u01ea\n\17\6\17\u01ec\n")
        buf.write("\17\r\17\16\17\u01ed\3\20\3\20\3\20\3\20\3\20\3\20\5\20")
        buf.write("\u01f6\n\20\3\20\3\20\5\20\u01fa\n\20\3\20\3\20\3\20\3")
        buf.write("\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u0206\n\20\5\20")
        buf.write("\u0208\n\20\3\21\3\21\3\22\3\22\3\23\3\23\3\23\3\23\5")
        buf.write("\23\u0212\n\23\3\23\5\23\u0215\n\23\3\24\3\24\3\25\3\25")
        buf.write("\3\26\3\26\3\27\3\27\3\30\3\30\3\31\3\31\3\31\3\31\5\31")
        buf.write("\u0225\n\31\3\32\3\32\3\32\3\33\3\33\3\33\3\34\3\34\3")
        buf.write("\34\3\35\3\35\3\35\3\36\3\36\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\5\37\u023e\n\37\3 \3 \3 \3!\3!\3")
        buf.write("!\3!\5!\u0247\n!\3\"\3\"\3\"\3#\3#\3#\3#\3#\3#\3#\3#\3")
        buf.write("#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3")
        buf.write("#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3")
        buf.write("#\3#\3#\3#\3#\3#\3#\5#\u027f\n#\3$\3$\3$\3$\5$\u0285\n")
        buf.write("$\3$\5$\u0288\n$\3%\3%\3%\5%\u028d\n%\3&\3&\3&\3&\2\2")
        buf.write("\'\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60")
        buf.write("\62\64\668:<>@BDFHJ\2\20\3\2\6\7\3\2\b\t\4\2\b\b\n\13")
        buf.write("\3\2\f\16\4\2\f\f\21\21\4\2\13\13\r\16\3\2\25\26\3\2\r")
        buf.write("\16\4\2\5\5\r\r\3\2\27\35\3\2\37 \4\2\13\13\r\r\4\2\4")
        buf.write("\4!!\3\2&\'\2\u030f\2f\3\2\2\2\4\u00a5\3\2\2\2\6\u00f5")
        buf.write("\3\2\2\2\b\u00f7\3\2\2\2\n\u0114\3\2\2\2\f\u0116\3\2\2")
        buf.write("\2\16\u0126\3\2\2\2\20\u0128\3\2\2\2\22\u0188\3\2\2\2")
        buf.write("\24\u018b\3\2\2\2\26\u019c\3\2\2\2\30\u01b7\3\2\2\2\32")
        buf.write("\u01ca\3\2\2\2\34\u01de\3\2\2\2\36\u0207\3\2\2\2 \u0209")
        buf.write("\3\2\2\2\"\u020b\3\2\2\2$\u020d\3\2\2\2&\u0216\3\2\2\2")
        buf.write("(\u0218\3\2\2\2*\u021a\3\2\2\2,\u021c\3\2\2\2.\u021e\3")
        buf.write("\2\2\2\60\u0224\3\2\2\2\62\u0226\3\2\2\2\64\u0229\3\2")
        buf.write("\2\2\66\u022c\3\2\2\28\u022f\3\2\2\2:\u0232\3\2\2\2<\u023d")
        buf.write("\3\2\2\2>\u023f\3\2\2\2@\u0246\3\2\2\2B\u0248\3\2\2\2")
        buf.write("D\u027e\3\2\2\2F\u0287\3\2\2\2H\u028c\3\2\2\2J\u028e\3")
        buf.write("\2\2\2LZ\7@\2\2MP\7D\2\2NQ\5(\25\2OQ\5,\27\2PN\3\2\2\2")
        buf.write("PO\3\2\2\2PQ\3\2\2\2QR\3\2\2\2R[\5\6\4\2SU\5\6\4\2TV\7")
        buf.write("D\2\2UT\3\2\2\2UV\3\2\2\2VX\3\2\2\2WY\5\4\3\2XW\3\2\2")
        buf.write("\2XY\3\2\2\2Y[\3\2\2\2ZM\3\2\2\2ZS\3\2\2\2[g\3\2\2\2\\")
        buf.write("^\5\6\4\2]_\7\3\2\2^]\3\2\2\2^_\3\2\2\2_a\3\2\2\2`b\7")
        buf.write("D\2\2a`\3\2\2\2ab\3\2\2\2bd\3\2\2\2ce\5\4\3\2dc\3\2\2")
        buf.write("\2de\3\2\2\2eg\3\2\2\2fL\3\2\2\2f\\\3\2\2\2go\3\2\2\2")
        buf.write("hk\5\22\n\2il\7\4\2\2jl\5\4\3\2ki\3\2\2\2kj\3\2\2\2kl")
        buf.write("\3\2\2\2ln\3\2\2\2mh\3\2\2\2nq\3\2\2\2om\3\2\2\2op\3\2")
        buf.write("\2\2ps\3\2\2\2qo\3\2\2\2rt\5\b\5\2sr\3\2\2\2st\3\2\2\2")
        buf.write("t\u0080\3\2\2\2u{\7\5\2\2vx\7\3\2\2wy\7D\2\2xw\3\2\2\2")
        buf.write("xy\3\2\2\2y{\3\2\2\2zu\3\2\2\2zv\3\2\2\2z{\3\2\2\2{}\3")
        buf.write("\2\2\2|~\5\4\3\2}|\3\2\2\2}~\3\2\2\2~\177\3\2\2\2\177")
        buf.write("\u0081\5\36\20\2\u0080z\3\2\2\2\u0080\u0081\3\2\2\2\u0081")
        buf.write("\u0084\3\2\2\2\u0082\u0083\t\2\2\2\u0083\u0085\5F$\2\u0084")
        buf.write("\u0082\3\2\2\2\u0084\u0085\3\2\2\2\u0085\u0087\3\2\2\2")
        buf.write("\u0086\u0088\5\22\n\2\u0087\u0086\3\2\2\2\u0087\u0088")
        buf.write("\3\2\2\2\u0088\u0096\3\2\2\2\u0089\u008b\t\3\2\2\u008a")
        buf.write("\u0089\3\2\2\2\u008a\u008b\3\2\2\2\u008b\u0090\3\2\2\2")
        buf.write("\u008c\u008e\5H%\2\u008d\u008f\7\4\2\2\u008e\u008d\3\2")
        buf.write("\2\2\u008e\u008f\3\2\2\2\u008f\u0091\3\2\2\2\u0090\u008c")
        buf.write("\3\2\2\2\u0091\u0092\3\2\2\2\u0092\u0090\3\2\2\2\u0092")
        buf.write("\u0093\3\2\2\2\u0093\u0095\3\2\2\2\u0094\u008a\3\2\2\2")
        buf.write("\u0095\u0098\3\2\2\2\u0096\u0094\3\2\2\2\u0096\u0097\3")
        buf.write("\2\2\2\u0097\u00a3\3\2\2\2\u0098\u0096\3\2\2\2\u0099\u009b")
        buf.write("\t\4\2\2\u009a\u0099\3\2\2\2\u009a\u009b\3\2\2\2\u009b")
        buf.write("\u009c\3\2\2\2\u009c\u009e\5J&\2\u009d\u009f\7\f\2\2\u009e")
        buf.write("\u009d\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a1\3\2\2\2")
        buf.write("\u00a0\u00a2\5J&\2\u00a1\u00a0\3\2\2\2\u00a1\u00a2\3\2")
        buf.write("\2\2\u00a2\u00a4\3\2\2\2\u00a3\u009a\3\2\2\2\u00a3\u00a4")
        buf.write("\3\2\2\2\u00a4\3\3\2\2\2\u00a5\u00a6\7E\2\2\u00a6\5\3")
        buf.write("\2\2\2\u00a7\u00f6\5\n\6\2\u00a8\u00a9\5\f\7\2\u00a9\u00aa")
        buf.write("\5D#\2\u00aa\u00f6\3\2\2\2\u00ab\u00ad\5 \21\2\u00ac\u00ab")
        buf.write("\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad\u00af\3\2\2\2\u00ae")
        buf.write("\u00b0\7N\2\2\u00af\u00ae\3\2\2\2\u00af\u00b0\3\2\2\2")
        buf.write("\u00b0\u00b5\3\2\2\2\u00b1\u00b3\5D#\2\u00b2\u00b4\7\4")
        buf.write("\2\2\u00b3\u00b2\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\u00b6")
        buf.write("\3\2\2\2\u00b5\u00b1\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7")
        buf.write("\u00b5\3\2\2\2\u00b7\u00b8\3\2\2\2\u00b8\u00c9\3\2\2\2")
        buf.write("\u00b9\u00bb\t\5\2\2\u00ba\u00bc\7N\2\2\u00bb\u00ba\3")
        buf.write("\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00be\3\2\2\2\u00bd\u00bf")
        buf.write("\7\17\2\2\u00be\u00bd\3\2\2\2\u00be\u00bf\3\2\2\2\u00bf")
        buf.write("\u00c1\3\2\2\2\u00c0\u00c2\7\20\2\2\u00c1\u00c0\3\2\2")
        buf.write("\2\u00c1\u00c2\3\2\2\2\u00c2\u00c5\3\2\2\2\u00c3\u00c6")
        buf.write("\5D#\2\u00c4\u00c6\5:\36\2\u00c5\u00c3\3\2\2\2\u00c5\u00c4")
        buf.write("\3\2\2\2\u00c6\u00c8\3\2\2\2\u00c7\u00b9\3\2\2\2\u00c8")
        buf.write("\u00cb\3\2\2\2\u00c9\u00c7\3\2\2\2\u00c9\u00ca\3\2\2\2")
        buf.write("\u00ca\u00cd\3\2\2\2\u00cb\u00c9\3\2\2\2\u00cc\u00ce\5")
        buf.write("\16\b\2\u00cd\u00cc\3\2\2\2\u00cd\u00ce\3\2\2\2\u00ce")
        buf.write("\u00f6\3\2\2\2\u00cf\u00d1\5 \21\2\u00d0\u00cf\3\2\2\2")
        buf.write("\u00d0\u00d1\3\2\2\2\u00d1\u00d4\3\2\2\2\u00d2\u00d5\5")
        buf.write("> \2\u00d3\u00d5\5D#\2\u00d4\u00d2\3\2\2\2\u00d4\u00d3")
        buf.write("\3\2\2\2\u00d5\u00dc\3\2\2\2\u00d6\u00d8\t\6\2\2\u00d7")
        buf.write("\u00d6\3\2\2\2\u00d7\u00d8\3\2\2\2\u00d8\u00d9\3\2\2\2")
        buf.write("\u00d9\u00db\5\34\17\2\u00da\u00d7\3\2\2\2\u00db\u00de")
        buf.write("\3\2\2\2\u00dc\u00da\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd")
        buf.write("\u00e5\3\2\2\2\u00de\u00dc\3\2\2\2\u00df\u00e1\t\7\2\2")
        buf.write("\u00e0\u00df\3\2\2\2\u00e0\u00e1\3\2\2\2\u00e1\u00e2\3")
        buf.write("\2\2\2\u00e2\u00e4\5\32\16\2\u00e3\u00e0\3\2\2\2\u00e4")
        buf.write("\u00e7\3\2\2\2\u00e5\u00e3\3\2\2\2\u00e5\u00e6\3\2\2\2")
        buf.write("\u00e6\u00ee\3\2\2\2\u00e7\u00e5\3\2\2\2\u00e8\u00ea\7")
        buf.write("\f\2\2\u00e9\u00e8\3\2\2\2\u00e9\u00ea\3\2\2\2\u00ea\u00eb")
        buf.write("\3\2\2\2\u00eb\u00ed\5\34\17\2\u00ec\u00e9\3\2\2\2\u00ed")
        buf.write("\u00f0\3\2\2\2\u00ee\u00ec\3\2\2\2\u00ee\u00ef\3\2\2\2")
        buf.write("\u00ef\u00f6\3\2\2\2\u00f0\u00ee\3\2\2\2\u00f1\u00f2\5")
        buf.write("D#\2\u00f2\u00f3\7\22\2\2\u00f3\u00f4\5> \2\u00f4\u00f6")
        buf.write("\3\2\2\2\u00f5\u00a7\3\2\2\2\u00f5\u00a8\3\2\2\2\u00f5")
        buf.write("\u00ac\3\2\2\2\u00f5\u00d0\3\2\2\2\u00f5\u00f1\3\2\2\2")
        buf.write("\u00f6\7\3\2\2\2\u00f7\u00f8\7\f\2\2\u00f8\u00f9\5D#\2")
        buf.write("\u00f9\t\3\2\2\2\u00fa\u00fc\7A\2\2\u00fb\u00fd\7D\2\2")
        buf.write("\u00fc\u00fb\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u00ff\3")
        buf.write("\2\2\2\u00fe\u0100\5\4\3\2\u00ff\u00fe\3\2\2\2\u00ff\u0100")
        buf.write("\3\2\2\2\u0100\u0111\3\2\2\2\u0101\u0112\5\20\t\2\u0102")
        buf.write("\u0104\5(\25\2\u0103\u0102\3\2\2\2\u0103\u0104\3\2\2\2")
        buf.write("\u0104\u0109\3\2\2\2\u0105\u0107\5D#\2\u0106\u0108\7\4")
        buf.write("\2\2\u0107\u0106\3\2\2\2\u0107\u0108\3\2\2\2\u0108\u010a")
        buf.write("\3\2\2\2\u0109\u0105\3\2\2\2\u010a\u010b\3\2\2\2\u010b")
        buf.write("\u0109\3\2\2\2\u010b\u010c\3\2\2\2\u010c\u010f\3\2\2\2")
        buf.write("\u010d\u010e\7\r\2\2\u010e\u0110\5D#\2\u010f\u010d\3\2")
        buf.write("\2\2\u010f\u0110\3\2\2\2\u0110\u0112\3\2\2\2\u0111\u0101")
        buf.write("\3\2\2\2\u0111\u0103\3\2\2\2\u0112\u0115\3\2\2\2\u0113")
        buf.write("\u0115\7B\2\2\u0114\u00fa\3\2\2\2\u0114\u0113\3\2\2\2")
        buf.write("\u0115\13\3\2\2\2\u0116\u0117\7C\2\2\u0117\r\3\2\2\2\u0118")
        buf.write("\u011a\7\23\2\2\u0119\u011b\5 \21\2\u011a\u0119\3\2\2")
        buf.write("\2\u011a\u011b\3\2\2\2\u011b\u011c\3\2\2\2\u011c\u011f")
        buf.write("\5D#\2\u011d\u011e\7\r\2\2\u011e\u0120\5D#\2\u011f\u011d")
        buf.write("\3\2\2\2\u011f\u0120\3\2\2\2\u0120\u0127\3\2\2\2\u0121")
        buf.write("\u0123\7\24\2\2\u0122\u0124\5 \21\2\u0123\u0122\3\2\2")
        buf.write("\2\u0123\u0124\3\2\2\2\u0124\u0125\3\2\2\2\u0125\u0127")
        buf.write("\5D#\2\u0126\u0118\3\2\2\2\u0126\u0121\3\2\2\2\u0127\17")
        buf.write("\3\2\2\2\u0128\u0129\t\b\2\2\u0129\u012b\t\t\2\2\u012a")
        buf.write("\u012c\7\20\2\2\u012b\u012a\3\2\2\2\u012b\u012c\3\2\2")
        buf.write("\2\u012c\u012d\3\2\2\2\u012d\u012e\5D#\2\u012e\21\3\2")
        buf.write("\2\2\u012f\u0132\5\"\22\2\u0130\u0132\5(\25\2\u0131\u012f")
        buf.write("\3\2\2\2\u0131\u0130\3\2\2\2\u0131\u0132\3\2\2\2\u0132")
        buf.write("\u0135\3\2\2\2\u0133\u0136\5\26\f\2\u0134\u0136\5\30\r")
        buf.write("\2\u0135\u0133\3\2\2\2\u0135\u0134\3\2\2\2\u0136\u0189")
        buf.write("\3\2\2\2\u0137\u013f\5\"\22\2\u0138\u0140\5\24\13\2\u0139")
        buf.write("\u013c\5D#\2\u013a\u013b\7\r\2\2\u013b\u013d\5D#\2\u013c")
        buf.write("\u013a\3\2\2\2\u013c\u013d\3\2\2\2\u013d\u0140\3\2\2\2")
        buf.write("\u013e\u0140\58\35\2\u013f\u0138\3\2\2\2\u013f\u0139\3")
        buf.write("\2\2\2\u013f\u013e\3\2\2\2\u0140\u0189\3\2\2\2\u0141\u0143")
        buf.write("\7\5\2\2\u0142\u0141\3\2\2\2\u0142\u0143\3\2\2\2\u0143")
        buf.write("\u0144\3\2\2\2\u0144\u0146\5&\24\2\u0145\u0147\7\13\2")
        buf.write("\2\u0146\u0145\3\2\2\2\u0146\u0147\3\2\2\2\u0147\u0149")
        buf.write("\3\2\2\2\u0148\u014a\7N\2\2\u0149\u0148\3\2\2\2\u0149")
        buf.write("\u014a\3\2\2\2\u014a\u014c\3\2\2\2\u014b\u014d\5(\25\2")
        buf.write("\u014c\u014b\3\2\2\2\u014c\u014d\3\2\2\2\u014d\u014f\3")
        buf.write("\2\2\2\u014e\u0150\5 \21\2\u014f\u014e\3\2\2\2\u014f\u0150")
        buf.write("\3\2\2\2\u0150\u0152\3\2\2\2\u0151\u0153\5D#\2\u0152\u0151")
        buf.write("\3\2\2\2\u0152\u0153\3\2\2\2\u0153\u016a\3\2\2\2\u0154")
        buf.write("\u016b\5\62\32\2\u0155\u016b\5\64\33\2\u0156\u0158\7\r")
        buf.write("\2\2\u0157\u0156\3\2\2\2\u0157\u0158\3\2\2\2\u0158\u015a")
        buf.write("\3\2\2\2\u0159\u015b\5.\30\2\u015a\u0159\3\2\2\2\u015a")
        buf.write("\u015b\3\2\2\2\u015b\u015e\3\2\2\2\u015c\u015f\5\60\31")
        buf.write("\2\u015d\u015f\5D#\2\u015e\u015c\3\2\2\2\u015e\u015d\3")
        buf.write("\2\2\2\u015f\u016b\3\2\2\2\u0160\u016b\5\66\34\2\u0161")
        buf.write("\u0162\7\r\2\2\u0162\u0163\5D#\2\u0163\u0167\7\f\2\2\u0164")
        buf.write("\u0166\5D#\2\u0165\u0164\3\2\2\2\u0166\u0169\3\2\2\2\u0167")
        buf.write("\u0165\3\2\2\2\u0167\u0168\3\2\2\2\u0168\u016b\3\2\2\2")
        buf.write("\u0169\u0167\3\2\2\2\u016a\u0154\3\2\2\2\u016a\u0155\3")
        buf.write("\2\2\2\u016a\u0157\3\2\2\2\u016a\u0160\3\2\2\2\u016a\u0161")
        buf.write("\3\2\2\2\u016a\u016b\3\2\2\2\u016b\u0189\3\2\2\2\u016c")
        buf.write("\u016e\t\n\2\2\u016d\u016c\3\2\2\2\u016d\u016e\3\2\2\2")
        buf.write("\u016e\u016f\3\2\2\2\u016f\u0176\5.\30\2\u0170\u0177\5")
        buf.write("\60\31\2\u0171\u0177\5\26\f\2\u0172\u0174\7N\2\2\u0173")
        buf.write("\u0172\3\2\2\2\u0173\u0174\3\2\2\2\u0174\u0175\3\2\2\2")
        buf.write("\u0175\u0177\5D#\2\u0176\u0170\3\2\2\2\u0176\u0171\3\2")
        buf.write("\2\2\u0176\u0173\3\2\2\2\u0177\u0189\3\2\2\2\u0178\u017b")
        buf.write("\5(\25\2\u0179\u017b\5*\26\2\u017a\u0178\3\2\2\2\u017a")
        buf.write("\u0179\3\2\2\2\u017b\u0184\3\2\2\2\u017c\u017e\7\17\2")
        buf.write("\2\u017d\u017c\3\2\2\2\u017d\u017e\3\2\2\2\u017e\u017f")
        buf.write("\3\2\2\2\u017f\u0182\5D#\2\u0180\u0181\7\r\2\2\u0181\u0183")
        buf.write("\5D#\2\u0182\u0180\3\2\2\2\u0182\u0183\3\2\2\2\u0183\u0185")
        buf.write("\3\2\2\2\u0184\u017d\3\2\2\2\u0184\u0185\3\2\2\2\u0185")
        buf.write("\u0189\3\2\2\2\u0186\u0189\5$\23\2\u0187\u0189\5\62\32")
        buf.write("\2\u0188\u0131\3\2\2\2\u0188\u0137\3\2\2\2\u0188\u0142")
        buf.write("\3\2\2\2\u0188\u016d\3\2\2\2\u0188\u017a\3\2\2\2\u0188")
        buf.write("\u0186\3\2\2\2\u0188\u0187\3\2\2\2\u0189\23\3\2\2\2\u018a")
        buf.write("\u018c\5\60\31\2\u018b\u018a\3\2\2\2\u018b\u018c\3\2\2")
        buf.write("\2\u018c\u018d\3\2\2\2\u018d\u0193\t\13\2\2\u018e\u0190")
        buf.write("\7\5\2\2\u018f\u0191\7\36\2\2\u0190\u018f\3\2\2\2\u0190")
        buf.write("\u0191\3\2\2\2\u0191\u0192\3\2\2\2\u0192\u0194\5\60\31")
        buf.write("\2\u0193\u018e\3\2\2\2\u0193\u0194\3\2\2\2\u0194\25\3")
        buf.write("\2\2\2\u0195\u0197\5\60\31\2\u0196\u0198\7\4\2\2\u0197")
        buf.write("\u0196\3\2\2\2\u0197\u0198\3\2\2\2\u0198\u019a\3\2\2\2")
        buf.write("\u0199\u019b\t\f\2\2\u019a\u0199\3\2\2\2\u019a\u019b\3")
        buf.write("\2\2\2\u019b\u019d\3\2\2\2\u019c\u0195\3\2\2\2\u019d\u019e")
        buf.write("\3\2\2\2\u019e\u019c\3\2\2\2\u019e\u019f\3\2\2\2\u019f")
        buf.write("\u01ad\3\2\2\2\u01a0\u01a2\t\r\2\2\u01a1\u01a0\3\2\2\2")
        buf.write("\u01a1\u01a2\3\2\2\2\u01a2\u01a5\3\2\2\2\u01a3\u01a6\5")
        buf.write("(\25\2\u01a4\u01a6\5,\27\2\u01a5\u01a3\3\2\2\2\u01a5\u01a4")
        buf.write("\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6\u01a7\3\2\2\2\u01a7")
        buf.write("\u01a9\5D#\2\u01a8\u01aa\t\16\2\2\u01a9\u01a8\3\2\2\2")
        buf.write("\u01a9\u01aa\3\2\2\2\u01aa\u01ac\3\2\2\2\u01ab\u01a1\3")
        buf.write("\2\2\2\u01ac\u01af\3\2\2\2\u01ad\u01ab\3\2\2\2\u01ad\u01ae")
        buf.write("\3\2\2\2\u01ae\27\3\2\2\2\u01af\u01ad\3\2\2\2\u01b0\u01b3")
        buf.write("\5\64\33\2\u01b1\u01b3\5\60\31\2\u01b2\u01b0\3\2\2\2\u01b2")
        buf.write("\u01b1\3\2\2\2\u01b3\u01b5\3\2\2\2\u01b4\u01b6\7\4\2\2")
        buf.write("\u01b5\u01b4\3\2\2\2\u01b5\u01b6\3\2\2\2\u01b6\u01b8\3")
        buf.write("\2\2\2\u01b7\u01b2\3\2\2\2\u01b8\u01b9\3\2\2\2\u01b9\u01b7")
        buf.write("\3\2\2\2\u01b9\u01ba\3\2\2\2\u01ba\u01bc\3\2\2\2\u01bb")
        buf.write("\u01bd\7\r\2\2\u01bc\u01bb\3\2\2\2\u01bc\u01bd\3\2\2\2")
        buf.write("\u01bd\u01bf\3\2\2\2\u01be\u01c0\5> \2\u01bf\u01be\3\2")
        buf.write("\2\2\u01bf\u01c0\3\2\2\2\u01c0\u01c3\3\2\2\2\u01c1\u01c2")
        buf.write("\t\7\2\2\u01c2\u01c4\5\32\16\2\u01c3\u01c1\3\2\2\2\u01c3")
        buf.write("\u01c4\3\2\2\2\u01c4\u01c7\3\2\2\2\u01c5\u01c6\7\f\2\2")
        buf.write("\u01c6\u01c8\5\34\17\2\u01c7\u01c5\3\2\2\2\u01c7\u01c8")
        buf.write("\3\2\2\2\u01c8\31\3\2\2\2\u01c9\u01cb\7N\2\2\u01ca\u01c9")
        buf.write("\3\2\2\2\u01ca\u01cb\3\2\2\2\u01cb\u01ce\3\2\2\2\u01cc")
        buf.write("\u01cf\5(\25\2\u01cd\u01cf\5,\27\2\u01ce\u01cc\3\2\2\2")
        buf.write("\u01ce\u01cd\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf\u01d1\3")
        buf.write("\2\2\2\u01d0\u01d2\5@!\2\u01d1\u01d0\3\2\2\2\u01d1\u01d2")
        buf.write("\3\2\2\2\u01d2\u01d4\3\2\2\2\u01d3\u01d5\7\r\2\2\u01d4")
        buf.write("\u01d3\3\2\2\2\u01d4\u01d5\3\2\2\2\u01d5\u01d9\3\2\2\2")
        buf.write("\u01d6\u01da\5@!\2\u01d7\u01da\5B\"\2\u01d8\u01da\5\24")
        buf.write("\13\2\u01d9\u01d6\3\2\2\2\u01d9\u01d7\3\2\2\2\u01d9\u01d8")
        buf.write("\3\2\2\2\u01da\u01db\3\2\2\2\u01db\u01d9\3\2\2\2\u01db")
        buf.write("\u01dc\3\2\2\2\u01dc\33\3\2\2\2\u01dd\u01df\7N\2\2\u01de")
        buf.write("\u01dd\3\2\2\2\u01de\u01df\3\2\2\2\u01df\u01e2\3\2\2\2")
        buf.write("\u01e0\u01e3\5(\25\2\u01e1\u01e3\5,\27\2\u01e2\u01e0\3")
        buf.write("\2\2\2\u01e2\u01e1\3\2\2\2\u01e2\u01e3\3\2\2\2\u01e3\u01eb")
        buf.write("\3\2\2\2\u01e4\u01e7\5@!\2\u01e5\u01e7\5B\"\2\u01e6\u01e4")
        buf.write("\3\2\2\2\u01e6\u01e5\3\2\2\2\u01e7\u01e9\3\2\2\2\u01e8")
        buf.write("\u01ea\7\4\2\2\u01e9\u01e8\3\2\2\2\u01e9\u01ea\3\2\2\2")
        buf.write("\u01ea\u01ec\3\2\2\2\u01eb\u01e6\3\2\2\2\u01ec\u01ed\3")
        buf.write("\2\2\2\u01ed\u01eb\3\2\2\2\u01ed\u01ee\3\2\2\2\u01ee\35")
        buf.write("\3\2\2\2\u01ef\u01f0\5D#\2\u01f0\u01f1\5.\30\2\u01f1\u01f2")
        buf.write("\5\60\31\2\u01f2\u0208\3\2\2\2\u01f3\u01f6\5\"\22\2\u01f4")
        buf.write("\u01f6\5(\25\2\u01f5\u01f3\3\2\2\2\u01f5\u01f4\3\2\2\2")
        buf.write("\u01f6\u01f9\3\2\2\2\u01f7\u01fa\5\26\f\2\u01f8\u01fa")
        buf.write("\5\30\r\2\u01f9\u01f7\3\2\2\2\u01f9\u01f8\3\2\2\2\u01fa")
        buf.write("\u0208\3\2\2\2\u01fb\u01fc\5\"\22\2\u01fc\u01fd\5D#\2")
        buf.write("\u01fd\u0208\3\2\2\2\u01fe\u01ff\5.\30\2\u01ff\u0200\5")
        buf.write("D#\2\u0200\u0208\3\2\2\2\u0201\u0202\5*\26\2\u0202\u0205")
        buf.write("\5D#\2\u0203\u0204\7\r\2\2\u0204\u0206\5D#\2\u0205\u0203")
        buf.write("\3\2\2\2\u0205\u0206\3\2\2\2\u0206\u0208\3\2\2\2\u0207")
        buf.write("\u01ef\3\2\2\2\u0207\u01f5\3\2\2\2\u0207\u01fb\3\2\2\2")
        buf.write("\u0207\u01fe\3\2\2\2\u0207\u0201\3\2\2\2\u0208\37\3\2")
        buf.write("\2\2\u0209\u020a\7F\2\2\u020a!\3\2\2\2\u020b\u020c\7G")
        buf.write("\2\2\u020c#\3\2\2\2\u020d\u0214\7\b\2\2\u020e\u0211\5")
        buf.write("D#\2\u020f\u0210\7\r\2\2\u0210\u0212\5D#\2\u0211\u020f")
        buf.write("\3\2\2\2\u0211\u0212\3\2\2\2\u0212\u0215\3\2\2\2\u0213")
        buf.write("\u0215\58\35\2\u0214\u020e\3\2\2\2\u0214\u0213\3\2\2\2")
        buf.write("\u0215%\3\2\2\2\u0216\u0217\7H\2\2\u0217\'\3\2\2\2\u0218")
        buf.write("\u0219\7I\2\2\u0219)\3\2\2\2\u021a\u021b\7J\2\2\u021b")
        buf.write("+\3\2\2\2\u021c\u021d\7K\2\2\u021d-\3\2\2\2\u021e\u021f")
        buf.write("\7L\2\2\u021f/\3\2\2\2\u0220\u0221\7\"\2\2\u0221\u0225")
        buf.write("\7N\2\2\u0222\u0223\7#\2\2\u0223\u0225\7N\2\2\u0224\u0220")
        buf.write("\3\2\2\2\u0224\u0222\3\2\2\2\u0225\61\3\2\2\2\u0226\u0227")
        buf.write("\7$\2\2\u0227\u0228\7N\2\2\u0228\63\3\2\2\2\u0229\u022a")
        buf.write("\7%\2\2\u022a\u022b\7N\2\2\u022b\65\3\2\2\2\u022c\u022d")
        buf.write("\7#\2\2\u022d\u022e\7N\2\2\u022e\67\3\2\2\2\u022f\u0230")
        buf.write("\5\60\31\2\u0230\u0231\t\17\2\2\u02319\3\2\2\2\u0232\u0233")
        buf.write("\7(\2\2\u0233;\3\2\2\2\u0234\u0235\5\60\31\2\u0235\u0236")
        buf.write("\7)\2\2\u0236\u023e\3\2\2\2\u0237\u0238\7)\2\2\u0238\u0239")
        buf.write("\5\60\31\2\u0239\u023a\7\22\2\2\u023a\u023b\5\60\31\2")
        buf.write("\u023b\u023c\7*\2\2\u023c\u023e\3\2\2\2\u023d\u0234\3")
        buf.write("\2\2\2\u023d\u0237\3\2\2\2\u023e=\3\2\2\2\u023f\u0240")
        buf.write("\7+\2\2\u0240\u0241\7N\2\2\u0241?\3\2\2\2\u0242\u0243")
        buf.write("\7,\2\2\u0243\u0247\7N\2\2\u0244\u0245\7-\2\2\u0245\u0247")
        buf.write("\7N\2\2\u0246\u0242\3\2\2\2\u0246\u0244\3\2\2\2\u0247")
        buf.write("A\3\2\2\2\u0248\u0249\7.\2\2\u0249\u024a\7N\2\2\u024a")
        buf.write("C\3\2\2\2\u024b\u024c\7/\2\2\u024c\u024d\7N\2\2\u024d")
        buf.write("\u027f\7M\2\2\u024e\u024f\7,\2\2\u024f\u027f\7N\2\2\u0250")
        buf.write("\u0251\7\60\2\2\u0251\u0252\7N\2\2\u0252\u027f\7M\2\2")
        buf.write("\u0253\u0254\7.\2\2\u0254\u027f\7N\2\2\u0255\u0256\7\61")
        buf.write("\2\2\u0256\u0257\7N\2\2\u0257\u027f\7M\2\2\u0258\u0259")
        buf.write("\7\62\2\2\u0259\u025a\7N\2\2\u025a\u027f\7M\2\2\u025b")
        buf.write("\u025c\7\63\2\2\u025c\u025d\7N\2\2\u025d\u027f\7M\2\2")
        buf.write("\u025e\u025f\7\64\2\2\u025f\u0260\7N\2\2\u0260\u027f\7")
        buf.write("M\2\2\u0261\u0262\7\65\2\2\u0262\u0263\7N\2\2\u0263\u027f")
        buf.write("\7M\2\2\u0264\u0265\7\66\2\2\u0265\u027f\7N\2\2\u0266")
        buf.write("\u0267\7\67\2\2\u0267\u0268\7N\2\2\u0268\u027f\7M\2\2")
        buf.write("\u0269\u026a\78\2\2\u026a\u026b\7N\2\2\u026b\u027f\7M")
        buf.write("\2\2\u026c\u026d\79\2\2\u026d\u026e\7N\2\2\u026e\u027f")
        buf.write("\7M\2\2\u026f\u0270\7:\2\2\u0270\u0271\7N\2\2\u0271\u027f")
        buf.write("\7M\2\2\u0272\u0273\7;\2\2\u0273\u0274\7N\2\2\u0274\u027f")
        buf.write("\7M\2\2\u0275\u0276\7<\2\2\u0276\u0277\7N\2\2\u0277\u027f")
        buf.write("\7M\2\2\u0278\u0279\7=\2\2\u0279\u027a\7N\2\2\u027a\u027f")
        buf.write("\7M\2\2\u027b\u027c\7>\2\2\u027c\u027d\7N\2\2\u027d\u027f")
        buf.write("\7M\2\2\u027e\u024b\3\2\2\2\u027e\u024e\3\2\2\2\u027e")
        buf.write("\u0250\3\2\2\2\u027e\u0253\3\2\2\2\u027e\u0255\3\2\2\2")
        buf.write("\u027e\u0258\3\2\2\2\u027e\u025b\3\2\2\2\u027e\u025e\3")
        buf.write("\2\2\2\u027e\u0261\3\2\2\2\u027e\u0264\3\2\2\2\u027e\u0266")
        buf.write("\3\2\2\2\u027e\u0269\3\2\2\2\u027e\u026c\3\2\2\2\u027e")
        buf.write("\u026f\3\2\2\2\u027e\u0272\3\2\2\2\u027e\u0275\3\2\2\2")
        buf.write("\u027e\u0278\3\2\2\2\u027e\u027b\3\2\2\2\u027fE\3\2\2")
        buf.write("\2\u0280\u0288\5\24\13\2\u0281\u0284\5D#\2\u0282\u0283")
        buf.write("\7\r\2\2\u0283\u0285\5D#\2\u0284\u0282\3\2\2\2\u0284\u0285")
        buf.write("\3\2\2\2\u0285\u0288\3\2\2\2\u0286\u0288\5<\37\2\u0287")
        buf.write("\u0280\3\2\2\2\u0287\u0281\3\2\2\2\u0287\u0286\3\2\2\2")
        buf.write("\u0288G\3\2\2\2\u0289\u028a\7-\2\2\u028a\u028d\7N\2\2")
        buf.write("\u028b\u028d\7?\2\2\u028c\u0289\3\2\2\2\u028c\u028b\3")
        buf.write("\2\2\2\u028dI\3\2\2\2\u028e\u028f\7$\2\2\u028f\u0290\7")
        buf.write("N\2\2\u0290K\3\2\2\2{PUXZ^adfkosxz}\u0080\u0084\u0087")
        buf.write("\u008a\u008e\u0092\u0096\u009a\u009e\u00a1\u00a3\u00ac")
        buf.write("\u00af\u00b3\u00b7\u00bb\u00be\u00c1\u00c5\u00c9\u00cd")
        buf.write("\u00d0\u00d4\u00d7\u00dc\u00e0\u00e5\u00e9\u00ee\u00f5")
        buf.write("\u00fc\u00ff\u0103\u0107\u010b\u010f\u0111\u0114\u011a")
        buf.write("\u011f\u0123\u0126\u012b\u0131\u0135\u013c\u013f\u0142")
        buf.write("\u0146\u0149\u014c\u014f\u0152\u0157\u015a\u015e\u0167")
        buf.write("\u016a\u016d\u0173\u0176\u017a\u017d\u0182\u0184\u0188")
        buf.write("\u018b\u0190\u0193\u0197\u019a\u019e\u01a1\u01a5\u01a9")
        buf.write("\u01ad\u01b2\u01b5\u01b9\u01bc\u01bf\u01c3\u01c7\u01ca")
        buf.write("\u01ce\u01d1\u01d4\u01d9\u01db\u01de\u01e2\u01e6\u01e9")
        buf.write("\u01ed\u01f5\u01f9\u0205\u0207\u0211\u0214\u0224\u023d")
        buf.write("\u0246\u027e\u0284\u0287\u028c")
        return buf.getvalue()


class GeoAnQuParser ( Parser ):

    grammarFileName = "GeoAnQu.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'that'", "'and'", "'with'", "'for each'", 
                     "'per'", "'in'", "'near'", "'on'", "'from'", "'to'", 
                     "'of'", "'for'", "'each'", "'new'", "'through'", "'by'", 
                     "'weighted by'", "'with similar'", "'best site'", "'best sites'", 
                     "'grids'", "'grid cells'", "'grid'", "'grid cell'", 
                     "'hexagonal grids'", "'hexagonal grid'", "'hexagon grid'", 
                     "'diameter of'", "'area'", "'buffer area'", "'or'", 
                     "'equantity'", "'epercent'", "'edate'", "'etime'", 
                     "'circle'", "'rectangle'", "'nearest neighbors'", "'distance band'", 
                     "'increments'", "'network'", "'object'", "'placename'", 
                     "'event'", "'field'", "'objectquality'", "'eventquality'", 
                     "'objconamount'", "'eveconamount'", "'conamount'", 
                     "'covamount'", "'amount'", "'objconobjconpro'", "'eveconobjconpro'", 
                     "'objconobjcovpro'", "'eveconobjcovpro'", "'conconpro'", 
                     "'concovpro'", "'covpro'", "'proportion'", "'world'", 
                     "<INVALID>", "'where'", "<INVALID>", "'how many'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "','" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "WH", "Location1", "Location2", 
                      "ConAm", "AUX", "Flase", "Aggregate", "TOPO", "Boolean", 
                      "Extrema", "Distance", "ExtreDist", "Compare", "ML", 
                      "DIGIT", "WS", "COMMA" ]

    RULE_start = 0
    RULE_false = 1
    RULE_measure = 2
    RULE_measure1 = 3
    RULE_location = 4
    RULE_conAm = 5
    RULE_weight = 6
    RULE_allocation = 7
    RULE_condition = 8
    RULE_grid = 9
    RULE_distField = 10
    RULE_serviceObj = 11
    RULE_origin = 12
    RULE_destination = 13
    RULE_subcon = 14
    RULE_aggre = 15
    RULE_topoR = 16
    RULE_topoRIn = 17
    RULE_boolR = 18
    RULE_extremaR = 19
    RULE_distanceR = 20
    RULE_extreDist = 21
    RULE_compareR = 22
    RULE_quantity = 23
    RULE_date = 24
    RULE_time = 25
    RULE_percent = 26
    RULE_densityNei = 27
    RULE_distBandNei = 28
    RULE_distBand = 29
    RULE_networkC = 30
    RULE_objectC = 31
    RULE_eventC = 32
    RULE_coreC = 33
    RULE_support = 34
    RULE_extent = 35
    RULE_temEx = 36

    ruleNames =  [ "start", "false", "measure", "measure1", "location", 
                   "conAm", "weight", "allocation", "condition", "grid", 
                   "distField", "serviceObj", "origin", "destination", "subcon", 
                   "aggre", "topoR", "topoRIn", "boolR", "extremaR", "distanceR", 
                   "extreDist", "compareR", "quantity", "date", "time", 
                   "percent", "densityNei", "distBandNei", "distBand", "networkC", 
                   "objectC", "eventC", "coreC", "support", "extent", "temEx" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    WH=62
    Location1=63
    Location2=64
    ConAm=65
    AUX=66
    Flase=67
    Aggregate=68
    TOPO=69
    Boolean=70
    Extrema=71
    Distance=72
    ExtreDist=73
    Compare=74
    ML=75
    DIGIT=76
    WS=77
    COMMA=78

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ConditionContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ConditionContext,i)


        def measure1(self):
            return self.getTypedRuleContext(GeoAnQuParser.Measure1Context,0)


        def subcon(self):
            return self.getTypedRuleContext(GeoAnQuParser.SubconContext,0)


        def support(self):
            return self.getTypedRuleContext(GeoAnQuParser.SupportContext,0)


        def temEx(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.TemExContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.TemExContext,i)


        def WH(self):
            return self.getToken(GeoAnQuParser.WH, 0)

        def measure(self):
            return self.getTypedRuleContext(GeoAnQuParser.MeasureContext,0)


        def false(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.FalseContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.FalseContext,i)


        def extent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtentContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtentContext,i)


        def AUX(self, i:int=None):
            if i is None:
                return self.getTokens(GeoAnQuParser.AUX)
            else:
                return self.getToken(GeoAnQuParser.AUX, i)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = GeoAnQuParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.WH]:
                self.state = 74
                self.match(GeoAnQuParser.WH)
                self.state = 88
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.AUX]:
                    self.state = 75
                    self.match(GeoAnQuParser.AUX)
                    self.state = 78
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.Extrema]:
                        self.state = 76
                        self.extremaR()
                        pass
                    elif token in [GeoAnQuParser.ExtreDist]:
                        self.state = 77
                        self.extreDist()
                        pass
                    elif token in [GeoAnQuParser.T__40, GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                        pass
                    else:
                        pass
                    self.state = 80
                    self.measure()
                    pass
                elif token in [GeoAnQuParser.T__40, GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                    self.state = 81
                    self.measure()
                    self.state = 83
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.AUX:
                        self.state = 82
                        self.match(GeoAnQuParser.AUX)


                    self.state = 86
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                    if la_ == 1:
                        self.state = 85
                        self.false()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [GeoAnQuParser.T__40, GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                self.state = 90
                self.measure()
                self.state = 92
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 91
                    self.match(GeoAnQuParser.T__0)


                self.state = 95
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.AUX:
                    self.state = 94
                    self.match(GeoAnQuParser.AUX)


                self.state = 98
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 97
                    self.false()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 109
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 102
                    self.condition()
                    self.state = 105
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        self.state = 103
                        self.match(GeoAnQuParser.T__1)

                    elif la_ == 2:
                        self.state = 104
                        self.false()

             
                self.state = 111
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 113
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__9:
                self.state = 112
                self.measure1()


            self.state = 126
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 120
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__2]:
                    self.state = 115
                    self.match(GeoAnQuParser.T__2)
                    pass
                elif token in [GeoAnQuParser.T__0]:
                    self.state = 116
                    self.match(GeoAnQuParser.T__0)
                    self.state = 118
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.AUX:
                        self.state = 117
                        self.match(GeoAnQuParser.AUX)


                    pass
                elif token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.Flase, GeoAnQuParser.TOPO, GeoAnQuParser.Extrema, GeoAnQuParser.Distance, GeoAnQuParser.Compare]:
                    pass
                else:
                    pass
                self.state = 123
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Flase:
                    self.state = 122
                    self.false()


                self.state = 125
                self.subcon()


            self.state = 130
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__3 or _la==GeoAnQuParser.T__4:
                self.state = 128
                _la = self._input.LA(1)
                if not(_la==GeoAnQuParser.T__3 or _la==GeoAnQuParser.T__4):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 129
                self.support()


            self.state = 133
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 132
                self.condition()


            self.state = 148
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 136
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__5 or _la==GeoAnQuParser.T__6:
                        self.state = 135
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__5 or _la==GeoAnQuParser.T__6):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 142 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 138
                            self.extent()
                            self.state = 140
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==GeoAnQuParser.T__1:
                                self.state = 139
                                self.match(GeoAnQuParser.T__1)



                        else:
                            raise NoViableAltException(self)
                        self.state = 144 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
             
                self.state = 150
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__33))) != 0):
                self.state = 152
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8))) != 0):
                    self.state = 151
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 154
                self.temEx()
                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__9:
                    self.state = 155
                    self.match(GeoAnQuParser.T__9)


                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__33:
                    self.state = 158
                    self.temEx()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FalseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Flase(self):
            return self.getToken(GeoAnQuParser.Flase, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_false

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalse" ):
                listener.enterFalse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalse" ):
                listener.exitFalse(self)




    def false(self):

        localctx = GeoAnQuParser.FalseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_false)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(GeoAnQuParser.Flase)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MeasureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def location(self):
            return self.getTypedRuleContext(GeoAnQuParser.LocationContext,0)


        def conAm(self):
            return self.getTypedRuleContext(GeoAnQuParser.ConAmContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(GeoAnQuParser.DIGIT)
            else:
                return self.getToken(GeoAnQuParser.DIGIT, i)

        def weight(self):
            return self.getTypedRuleContext(GeoAnQuParser.WeightContext,0)


        def distBandNei(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DistBandNeiContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DistBandNeiContext,i)


        def networkC(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkCContext,0)


        def destination(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DestinationContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,i)


        def origin(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.OriginContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.OriginContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_measure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasure" ):
                listener.enterMeasure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasure" ):
                listener.exitMeasure(self)




    def measure(self):

        localctx = GeoAnQuParser.MeasureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_measure)
        self._la = 0 # Token type
        try:
            self.state = 243
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 165
                self.location()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 166
                self.conAm()
                self.state = 167
                self.coreC()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 170
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 169
                    self.aggre()


                self.state = 173
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.DIGIT:
                    self.state = 172
                    self.match(GeoAnQuParser.DIGIT)


                self.state = 179 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 175
                        self.coreC()
                        self.state = 177
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__1:
                            self.state = 176
                            self.match(GeoAnQuParser.T__1)



                    else:
                        raise NoViableAltException(self)
                    self.state = 181 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

                self.state = 199
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 183
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 185
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.DIGIT:
                            self.state = 184
                            self.match(GeoAnQuParser.DIGIT)


                        self.state = 188
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__12:
                            self.state = 187
                            self.match(GeoAnQuParser.T__12)


                        self.state = 191
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__13:
                            self.state = 190
                            self.match(GeoAnQuParser.T__13)


                        self.state = 195
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59]:
                            self.state = 193
                            self.coreC()
                            pass
                        elif token in [GeoAnQuParser.T__37]:
                            self.state = 194
                            self.distBandNei()
                            pass
                        else:
                            raise NoViableAltException(self)
                 
                    self.state = 201
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                self.state = 203
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__16 or _la==GeoAnQuParser.T__17:
                    self.state = 202
                    self.weight()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 206
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 205
                    self.aggre()


                self.state = 210
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__40]:
                    self.state = 208
                    self.networkC()
                    pass
                elif token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59]:
                    self.state = 209
                    self.coreC()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 218
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 213
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__9 or _la==GeoAnQuParser.T__14:
                            self.state = 212
                            _la = self._input.LA(1)
                            if not(_la==GeoAnQuParser.T__9 or _la==GeoAnQuParser.T__14):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 215
                        self.destination() 
                    self.state = 220
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

                self.state = 227
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 222
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                        if la_ == 1:
                            self.state = 221
                            _la = self._input.LA(1)
                            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 224
                        self.origin() 
                    self.state = 229
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

                self.state = 236
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,42,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 231
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__9:
                            self.state = 230
                            self.match(GeoAnQuParser.T__9)


                        self.state = 233
                        self.destination() 
                    self.state = 238
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,42,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 239
                self.coreC()
                self.state = 240
                self.match(GeoAnQuParser.T__15)
                self.state = 241
                self.networkC()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Measure1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self):
            return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_measure1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasure1" ):
                listener.enterMeasure1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasure1" ):
                listener.exitMeasure1(self)




    def measure1(self):

        localctx = GeoAnQuParser.Measure1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_measure1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(GeoAnQuParser.T__9)
            self.state = 246
            self.coreC()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Location1(self):
            return self.getToken(GeoAnQuParser.Location1, 0)

        def allocation(self):
            return self.getTypedRuleContext(GeoAnQuParser.AllocationContext,0)


        def AUX(self):
            return self.getToken(GeoAnQuParser.AUX, 0)

        def false(self):
            return self.getTypedRuleContext(GeoAnQuParser.FalseContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def Location2(self):
            return self.getToken(GeoAnQuParser.Location2, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)




    def location(self):

        localctx = GeoAnQuParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.state = 274
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Location1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 248
                self.match(GeoAnQuParser.Location1)
                self.state = 250
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.AUX:
                    self.state = 249
                    self.match(GeoAnQuParser.AUX)


                self.state = 253
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Flase:
                    self.state = 252
                    self.false()


                self.state = 271
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__18, GeoAnQuParser.T__19]:
                    self.state = 255
                    self.allocation()
                    pass
                elif token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.Extrema]:
                    self.state = 257
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.Extrema:
                        self.state = 256
                        self.extremaR()


                    self.state = 263 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 259
                            self.coreC()
                            self.state = 261
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==GeoAnQuParser.T__1:
                                self.state = 260
                                self.match(GeoAnQuParser.T__1)



                        else:
                            raise NoViableAltException(self)
                        self.state = 265 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,48,self._ctx)

                    self.state = 269
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                    if la_ == 1:
                        self.state = 267
                        self.match(GeoAnQuParser.T__10)
                        self.state = 268
                        self.coreC()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [GeoAnQuParser.Location2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 273
                self.match(GeoAnQuParser.Location2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConAmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ConAm(self):
            return self.getToken(GeoAnQuParser.ConAm, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_conAm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConAm" ):
                listener.enterConAm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConAm" ):
                listener.exitConAm(self)




    def conAm(self):

        localctx = GeoAnQuParser.ConAmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_conAm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.match(GeoAnQuParser.ConAm)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WeightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_weight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeight" ):
                listener.enterWeight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeight" ):
                listener.exitWeight(self)




    def weight(self):

        localctx = GeoAnQuParser.WeightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_weight)
        self._la = 0 # Token type
        try:
            self.state = 292
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__16]:
                self.enterOuterAlt(localctx, 1)
                self.state = 278
                self.match(GeoAnQuParser.T__16)
                self.state = 280
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 279
                    self.aggre()


                self.state = 282
                self.coreC()
                self.state = 285
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
                if la_ == 1:
                    self.state = 283
                    self.match(GeoAnQuParser.T__10)
                    self.state = 284
                    self.coreC()


                pass
            elif token in [GeoAnQuParser.T__17]:
                self.enterOuterAlt(localctx, 2)
                self.state = 287
                self.match(GeoAnQuParser.T__17)
                self.state = 289
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 288
                    self.aggre()


                self.state = 291
                self.coreC()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self):
            return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_allocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllocation" ):
                listener.enterAllocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllocation" ):
                listener.exitAllocation(self)




    def allocation(self):

        localctx = GeoAnQuParser.AllocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_allocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__18 or _la==GeoAnQuParser.T__19):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 295
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__10 or _la==GeoAnQuParser.T__11):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__13:
                self.state = 296
                self.match(GeoAnQuParser.T__13)


            self.state = 299
            self.coreC()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def serviceObj(self):
            return self.getTypedRuleContext(GeoAnQuParser.ServiceObjContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def grid(self):
            return self.getTypedRuleContext(GeoAnQuParser.GridContext,0)


        def densityNei(self):
            return self.getTypedRuleContext(GeoAnQuParser.DensityNeiContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def boolR(self):
            return self.getTypedRuleContext(GeoAnQuParser.BoolRContext,0)


        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def date(self):
            return self.getTypedRuleContext(GeoAnQuParser.DateContext,0)


        def time(self):
            return self.getTypedRuleContext(GeoAnQuParser.TimeContext,0)


        def percent(self):
            return self.getTypedRuleContext(GeoAnQuParser.PercentContext,0)


        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def distanceR(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistanceRContext,0)


        def topoRIn(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRInContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = GeoAnQuParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 390
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 303
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.TOPO]:
                    self.state = 301
                    self.topoR()
                    pass
                elif token in [GeoAnQuParser.Extrema]:
                    self.state = 302
                    self.extremaR()
                    pass
                elif token in [GeoAnQuParser.T__31, GeoAnQuParser.T__32, GeoAnQuParser.T__34]:
                    pass
                else:
                    pass
                self.state = 307
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                if la_ == 1:
                    self.state = 305
                    self.distField()
                    pass

                elif la_ == 2:
                    self.state = 306
                    self.serviceObj()
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 309
                self.topoR()
                self.state = 317
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                if la_ == 1:
                    self.state = 310
                    self.grid()
                    pass

                elif la_ == 2:
                    self.state = 311
                    self.coreC()
                    self.state = 314
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                    if la_ == 1:
                        self.state = 312
                        self.match(GeoAnQuParser.T__10)
                        self.state = 313
                        self.coreC()


                    pass

                elif la_ == 3:
                    self.state = 316
                    self.densityNei()
                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__2:
                    self.state = 319
                    self.match(GeoAnQuParser.T__2)


                self.state = 322
                self.boolR()
                self.state = 324
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 323
                    self.match(GeoAnQuParser.T__8)


                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.DIGIT:
                    self.state = 326
                    self.match(GeoAnQuParser.DIGIT)


                self.state = 330
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
                if la_ == 1:
                    self.state = 329
                    self.extremaR()


                self.state = 333
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 332
                    self.aggre()


                self.state = 336
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                if la_ == 1:
                    self.state = 335
                    self.coreC()


                self.state = 360
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
                if la_ == 1:
                    self.state = 338
                    self.date()

                elif la_ == 2:
                    self.state = 339
                    self.time()

                elif la_ == 3:
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__10:
                        self.state = 340
                        self.match(GeoAnQuParser.T__10)


                    self.state = 344
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.Compare:
                        self.state = 343
                        self.compareR()


                    self.state = 348
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__31, GeoAnQuParser.T__32]:
                        self.state = 346
                        self.quantity()
                        pass
                    elif token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59]:
                        self.state = 347
                        self.coreC()
                        pass
                    else:
                        raise NoViableAltException(self)


                elif la_ == 4:
                    self.state = 350
                    self.percent()

                elif la_ == 5:
                    self.state = 351
                    self.match(GeoAnQuParser.T__10)
                    self.state = 352
                    self.coreC()
                    self.state = 353
                    self.match(GeoAnQuParser.T__9)
                    self.state = 357
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,70,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 354
                            self.coreC() 
                        self.state = 359
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,70,self._ctx)



                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 363
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__2 or _la==GeoAnQuParser.T__10:
                    self.state = 362
                    _la = self._input.LA(1)
                    if not(_la==GeoAnQuParser.T__2 or _la==GeoAnQuParser.T__10):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 365
                self.compareR()
                self.state = 372
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 366
                    self.quantity()
                    pass

                elif la_ == 2:
                    self.state = 367
                    self.distField()
                    pass

                elif la_ == 3:
                    self.state = 369
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.DIGIT:
                        self.state = 368
                        self.match(GeoAnQuParser.DIGIT)


                    self.state = 371
                    self.coreC()
                    pass


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 376
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.Extrema]:
                    self.state = 374
                    self.extremaR()
                    pass
                elif token in [GeoAnQuParser.Distance]:
                    self.state = 375
                    self.distanceR()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 386
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
                if la_ == 1:
                    self.state = 379
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__12:
                        self.state = 378
                        self.match(GeoAnQuParser.T__12)


                    self.state = 381
                    self.coreC()
                    self.state = 384
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                    if la_ == 1:
                        self.state = 382
                        self.match(GeoAnQuParser.T__10)
                        self.state = 383
                        self.coreC()




                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 388
                self.topoRIn()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 389
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GridContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_grid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrid" ):
                listener.enterGrid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrid" ):
                listener.exitGrid(self)




    def grid(self):

        localctx = GeoAnQuParser.GridContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_grid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__31 or _la==GeoAnQuParser.T__32:
                self.state = 392
                self.quantity()


            self.state = 395
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__20) | (1 << GeoAnQuParser.T__21) | (1 << GeoAnQuParser.T__22) | (1 << GeoAnQuParser.T__23) | (1 << GeoAnQuParser.T__24) | (1 << GeoAnQuParser.T__25) | (1 << GeoAnQuParser.T__26))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 401
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
            if la_ == 1:
                self.state = 396
                self.match(GeoAnQuParser.T__2)
                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__27:
                    self.state = 397
                    self.match(GeoAnQuParser.T__27)


                self.state = 400
                self.quantity()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistFieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def extremaR(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtremaRContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,i)


        def extreDist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtreDistContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distField

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistField" ):
                listener.enterDistField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistField" ):
                listener.exitDistField(self)




    def distField(self):

        localctx = GeoAnQuParser.DistFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_distField)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 403
                    self.quantity()
                    self.state = 405
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                    if la_ == 1:
                        self.state = 404
                        self.match(GeoAnQuParser.T__1)


                    self.state = 408
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__28 or _la==GeoAnQuParser.T__29:
                        self.state = 407
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__28 or _la==GeoAnQuParser.T__29):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()



                else:
                    raise NoViableAltException(self)
                self.state = 412 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

            self.state = 427
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,89,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 415
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__8 or _la==GeoAnQuParser.T__10:
                        self.state = 414
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__8 or _la==GeoAnQuParser.T__10):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 419
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.Extrema]:
                        self.state = 417
                        self.extremaR()
                        pass
                    elif token in [GeoAnQuParser.ExtreDist]:
                        self.state = 418
                        self.extreDist()
                        pass
                    elif token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59]:
                        pass
                    else:
                        pass
                    self.state = 421
                    self.coreC()
                    self.state = 423
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                    if la_ == 1:
                        self.state = 422
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__1 or _la==GeoAnQuParser.T__30):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

             
                self.state = 429
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,89,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServiceObjContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def networkC(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkCContext,0)


        def origin(self):
            return self.getTypedRuleContext(GeoAnQuParser.OriginContext,0)


        def destination(self):
            return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,0)


        def time(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.TimeContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.TimeContext,i)


        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_serviceObj

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServiceObj" ):
                listener.enterServiceObj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServiceObj" ):
                listener.exitServiceObj(self)




    def serviceObj(self):

        localctx = GeoAnQuParser.ServiceObjContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_serviceObj)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 437 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 432
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__34]:
                        self.state = 430
                        self.time()
                        pass
                    elif token in [GeoAnQuParser.T__31, GeoAnQuParser.T__32]:
                        self.state = 431
                        self.quantity()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 435
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                    if la_ == 1:
                        self.state = 434
                        self.match(GeoAnQuParser.T__1)



                else:
                    raise NoViableAltException(self)
                self.state = 439 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

            self.state = 442
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 441
                self.match(GeoAnQuParser.T__10)


            self.state = 445
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__40:
                self.state = 444
                self.networkC()


            self.state = 449
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                self.state = 447
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 448
                self.origin()


            self.state = 453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
            if la_ == 1:
                self.state = 451
                self.match(GeoAnQuParser.T__9)
                self.state = 452
                self.destination()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OriginContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def objectC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ObjectCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ObjectCContext,i)


        def eventC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.EventCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.EventCContext,i)


        def grid(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.GridContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.GridContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_origin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrigin" ):
                listener.enterOrigin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrigin" ):
                listener.exitOrigin(self)




    def origin(self):

        localctx = GeoAnQuParser.OriginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_origin)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 456
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.DIGIT:
                self.state = 455
                self.match(GeoAnQuParser.DIGIT)


            self.state = 460
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Extrema]:
                self.state = 458
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.ExtreDist]:
                self.state = 459
                self.extreDist()
                pass
            elif token in [GeoAnQuParser.T__10, GeoAnQuParser.T__20, GeoAnQuParser.T__21, GeoAnQuParser.T__22, GeoAnQuParser.T__23, GeoAnQuParser.T__24, GeoAnQuParser.T__25, GeoAnQuParser.T__26, GeoAnQuParser.T__31, GeoAnQuParser.T__32, GeoAnQuParser.T__41, GeoAnQuParser.T__42, GeoAnQuParser.T__43]:
                pass
            else:
                pass
            self.state = 463
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 462
                self.objectC()


            self.state = 466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__10:
                self.state = 465
                self.match(GeoAnQuParser.T__10)


            self.state = 471 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 471
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__41, GeoAnQuParser.T__42]:
                        self.state = 468
                        self.objectC()
                        pass
                    elif token in [GeoAnQuParser.T__43]:
                        self.state = 469
                        self.eventC()
                        pass
                    elif token in [GeoAnQuParser.T__20, GeoAnQuParser.T__21, GeoAnQuParser.T__22, GeoAnQuParser.T__23, GeoAnQuParser.T__24, GeoAnQuParser.T__25, GeoAnQuParser.T__26, GeoAnQuParser.T__31, GeoAnQuParser.T__32]:
                        self.state = 470
                        self.grid()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 473 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,102,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestinationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def objectC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ObjectCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ObjectCContext,i)


        def eventC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.EventCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.EventCContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_destination

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestination" ):
                listener.enterDestination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestination" ):
                listener.exitDestination(self)




    def destination(self):

        localctx = GeoAnQuParser.DestinationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_destination)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.DIGIT:
                self.state = 475
                self.match(GeoAnQuParser.DIGIT)


            self.state = 480
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Extrema]:
                self.state = 478
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.ExtreDist]:
                self.state = 479
                self.extreDist()
                pass
            elif token in [GeoAnQuParser.T__41, GeoAnQuParser.T__42, GeoAnQuParser.T__43]:
                pass
            else:
                pass
            self.state = 489 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 484
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__41, GeoAnQuParser.T__42]:
                        self.state = 482
                        self.objectC()
                        pass
                    elif token in [GeoAnQuParser.T__43]:
                        self.state = 483
                        self.eventC()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 487
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
                    if la_ == 1:
                        self.state = 486
                        self.match(GeoAnQuParser.T__1)



                else:
                    raise NoViableAltException(self)
                self.state = 491 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,107,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubconContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def serviceObj(self):
            return self.getTypedRuleContext(GeoAnQuParser.ServiceObjContext,0)


        def distanceR(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistanceRContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_subcon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubcon" ):
                listener.enterSubcon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubcon" ):
                listener.exitSubcon(self)




    def subcon(self):

        localctx = GeoAnQuParser.SubconContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_subcon)
        try:
            self.state = 517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 493
                self.coreC()
                self.state = 494
                self.compareR()
                self.state = 495
                self.quantity()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 499
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.TOPO]:
                    self.state = 497
                    self.topoR()
                    pass
                elif token in [GeoAnQuParser.Extrema]:
                    self.state = 498
                    self.extremaR()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 503
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 501
                    self.distField()
                    pass

                elif la_ == 2:
                    self.state = 502
                    self.serviceObj()
                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 505
                self.topoR()
                self.state = 506
                self.coreC()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 508
                self.compareR()
                self.state = 509
                self.coreC()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 511
                self.distanceR()
                self.state = 512
                self.coreC()
                self.state = 515
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
                if la_ == 1:
                    self.state = 513
                    self.match(GeoAnQuParser.T__10)
                    self.state = 514
                    self.coreC()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Aggregate(self):
            return self.getToken(GeoAnQuParser.Aggregate, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_aggre

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggre" ):
                listener.enterAggre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggre" ):
                listener.exitAggre(self)




    def aggre(self):

        localctx = GeoAnQuParser.AggreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_aggre)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 519
            self.match(GeoAnQuParser.Aggregate)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopoRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOPO(self):
            return self.getToken(GeoAnQuParser.TOPO, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_topoR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopoR" ):
                listener.enterTopoR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopoR" ):
                listener.exitTopoR(self)




    def topoR(self):

        localctx = GeoAnQuParser.TopoRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_topoR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 521
            self.match(GeoAnQuParser.TOPO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopoRInContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def densityNei(self):
            return self.getTypedRuleContext(GeoAnQuParser.DensityNeiContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_topoRIn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopoRIn" ):
                listener.enterTopoRIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopoRIn" ):
                listener.exitTopoRIn(self)




    def topoRIn(self):

        localctx = GeoAnQuParser.TopoRInContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_topoRIn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 523
            self.match(GeoAnQuParser.T__5)
            self.state = 530
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__41, GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59]:
                self.state = 524
                self.coreC()
                self.state = 527
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                if la_ == 1:
                    self.state = 525
                    self.match(GeoAnQuParser.T__10)
                    self.state = 526
                    self.coreC()


                pass
            elif token in [GeoAnQuParser.T__31, GeoAnQuParser.T__32]:
                self.state = 529
                self.densityNei()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Boolean(self):
            return self.getToken(GeoAnQuParser.Boolean, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_boolR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolR" ):
                listener.enterBoolR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolR" ):
                listener.exitBoolR(self)




    def boolR(self):

        localctx = GeoAnQuParser.BoolRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_boolR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.match(GeoAnQuParser.Boolean)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtremaRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Extrema(self):
            return self.getToken(GeoAnQuParser.Extrema, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extremaR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtremaR" ):
                listener.enterExtremaR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtremaR" ):
                listener.exitExtremaR(self)




    def extremaR(self):

        localctx = GeoAnQuParser.ExtremaRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_extremaR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 534
            self.match(GeoAnQuParser.Extrema)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistanceRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Distance(self):
            return self.getToken(GeoAnQuParser.Distance, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distanceR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistanceR" ):
                listener.enterDistanceR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistanceR" ):
                listener.exitDistanceR(self)




    def distanceR(self):

        localctx = GeoAnQuParser.DistanceRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_distanceR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 536
            self.match(GeoAnQuParser.Distance)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtreDistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ExtreDist(self):
            return self.getToken(GeoAnQuParser.ExtreDist, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extreDist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtreDist" ):
                listener.enterExtreDist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtreDist" ):
                listener.exitExtreDist(self)




    def extreDist(self):

        localctx = GeoAnQuParser.ExtreDistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_extreDist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 538
            self.match(GeoAnQuParser.ExtreDist)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompareRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Compare(self):
            return self.getToken(GeoAnQuParser.Compare, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_compareR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompareR" ):
                listener.enterCompareR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompareR" ):
                listener.exitCompareR(self)




    def compareR(self):

        localctx = GeoAnQuParser.CompareRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_compareR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.match(GeoAnQuParser.Compare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_quantity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantity" ):
                listener.enterQuantity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantity" ):
                listener.exitQuantity(self)




    def quantity(self):

        localctx = GeoAnQuParser.QuantityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_quantity)
        try:
            self.state = 546
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__31]:
                self.enterOuterAlt(localctx, 1)
                self.state = 542
                self.match(GeoAnQuParser.T__31)
                self.state = 543
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 544
                self.match(GeoAnQuParser.T__32)
                self.state = 545
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = GeoAnQuParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 548
            self.match(GeoAnQuParser.T__33)
            self.state = 549
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)




    def time(self):

        localctx = GeoAnQuParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.match(GeoAnQuParser.T__34)
            self.state = 552
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercent" ):
                listener.enterPercent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercent" ):
                listener.exitPercent(self)




    def percent(self):

        localctx = GeoAnQuParser.PercentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.match(GeoAnQuParser.T__32)
            self.state = 555
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DensityNeiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_densityNei

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDensityNei" ):
                listener.enterDensityNei(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDensityNei" ):
                listener.exitDensityNei(self)




    def densityNei(self):

        localctx = GeoAnQuParser.DensityNeiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_densityNei)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 557
            self.quantity()
            self.state = 558
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__35 or _la==GeoAnQuParser.T__36):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistBandNeiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distBandNei

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistBandNei" ):
                listener.enterDistBandNei(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistBandNei" ):
                listener.exitDistBandNei(self)




    def distBandNei(self):

        localctx = GeoAnQuParser.DistBandNeiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_distBandNei)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 560
            self.match(GeoAnQuParser.T__37)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistBandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distBand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistBand" ):
                listener.enterDistBand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistBand" ):
                listener.exitDistBand(self)




    def distBand(self):

        localctx = GeoAnQuParser.DistBandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_distBand)
        try:
            self.state = 571
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__31, GeoAnQuParser.T__32]:
                self.enterOuterAlt(localctx, 1)
                self.state = 562
                self.quantity()
                self.state = 563
                self.match(GeoAnQuParser.T__38)
                pass
            elif token in [GeoAnQuParser.T__38]:
                self.enterOuterAlt(localctx, 2)
                self.state = 565
                self.match(GeoAnQuParser.T__38)
                self.state = 566
                self.quantity()
                self.state = 567
                self.match(GeoAnQuParser.T__15)
                self.state = 568
                self.quantity()
                self.state = 569
                self.match(GeoAnQuParser.T__39)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NetworkCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_networkC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNetworkC" ):
                listener.enterNetworkC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNetworkC" ):
                listener.exitNetworkC(self)




    def networkC(self):

        localctx = GeoAnQuParser.NetworkCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_networkC)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self.match(GeoAnQuParser.T__40)
            self.state = 574
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_objectC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectC" ):
                listener.enterObjectC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectC" ):
                listener.exitObjectC(self)




    def objectC(self):

        localctx = GeoAnQuParser.ObjectCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_objectC)
        try:
            self.state = 580
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 576
                self.match(GeoAnQuParser.T__41)
                self.state = 577
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__42]:
                self.enterOuterAlt(localctx, 2)
                self.state = 578
                self.match(GeoAnQuParser.T__42)
                self.state = 579
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_eventC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventC" ):
                listener.enterEventC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventC" ):
                listener.exitEventC(self)




    def eventC(self):

        localctx = GeoAnQuParser.EventCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_eventC)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 582
            self.match(GeoAnQuParser.T__43)
            self.state = 583
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CoreCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def ML(self):
            return self.getToken(GeoAnQuParser.ML, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_coreC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoreC" ):
                listener.enterCoreC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoreC" ):
                listener.exitCoreC(self)




    def coreC(self):

        localctx = GeoAnQuParser.CoreCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_coreC)
        try:
            self.state = 636
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__44]:
                self.enterOuterAlt(localctx, 1)
                self.state = 585
                self.match(GeoAnQuParser.T__44)
                self.state = 586
                self.match(GeoAnQuParser.DIGIT)
                self.state = 587
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 588
                self.match(GeoAnQuParser.T__41)
                self.state = 589
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 590
                self.match(GeoAnQuParser.T__45)
                self.state = 591
                self.match(GeoAnQuParser.DIGIT)
                self.state = 592
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__43]:
                self.enterOuterAlt(localctx, 4)
                self.state = 593
                self.match(GeoAnQuParser.T__43)
                self.state = 594
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__46]:
                self.enterOuterAlt(localctx, 5)
                self.state = 595
                self.match(GeoAnQuParser.T__46)
                self.state = 596
                self.match(GeoAnQuParser.DIGIT)
                self.state = 597
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__47]:
                self.enterOuterAlt(localctx, 6)
                self.state = 598
                self.match(GeoAnQuParser.T__47)
                self.state = 599
                self.match(GeoAnQuParser.DIGIT)
                self.state = 600
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__48]:
                self.enterOuterAlt(localctx, 7)
                self.state = 601
                self.match(GeoAnQuParser.T__48)
                self.state = 602
                self.match(GeoAnQuParser.DIGIT)
                self.state = 603
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__49]:
                self.enterOuterAlt(localctx, 8)
                self.state = 604
                self.match(GeoAnQuParser.T__49)
                self.state = 605
                self.match(GeoAnQuParser.DIGIT)
                self.state = 606
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__50]:
                self.enterOuterAlt(localctx, 9)
                self.state = 607
                self.match(GeoAnQuParser.T__50)
                self.state = 608
                self.match(GeoAnQuParser.DIGIT)
                self.state = 609
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__51]:
                self.enterOuterAlt(localctx, 10)
                self.state = 610
                self.match(GeoAnQuParser.T__51)
                self.state = 611
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__52]:
                self.enterOuterAlt(localctx, 11)
                self.state = 612
                self.match(GeoAnQuParser.T__52)
                self.state = 613
                self.match(GeoAnQuParser.DIGIT)
                self.state = 614
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__53]:
                self.enterOuterAlt(localctx, 12)
                self.state = 615
                self.match(GeoAnQuParser.T__53)
                self.state = 616
                self.match(GeoAnQuParser.DIGIT)
                self.state = 617
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__54]:
                self.enterOuterAlt(localctx, 13)
                self.state = 618
                self.match(GeoAnQuParser.T__54)
                self.state = 619
                self.match(GeoAnQuParser.DIGIT)
                self.state = 620
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__55]:
                self.enterOuterAlt(localctx, 14)
                self.state = 621
                self.match(GeoAnQuParser.T__55)
                self.state = 622
                self.match(GeoAnQuParser.DIGIT)
                self.state = 623
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__56]:
                self.enterOuterAlt(localctx, 15)
                self.state = 624
                self.match(GeoAnQuParser.T__56)
                self.state = 625
                self.match(GeoAnQuParser.DIGIT)
                self.state = 626
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__57]:
                self.enterOuterAlt(localctx, 16)
                self.state = 627
                self.match(GeoAnQuParser.T__57)
                self.state = 628
                self.match(GeoAnQuParser.DIGIT)
                self.state = 629
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__58]:
                self.enterOuterAlt(localctx, 17)
                self.state = 630
                self.match(GeoAnQuParser.T__58)
                self.state = 631
                self.match(GeoAnQuParser.DIGIT)
                self.state = 632
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__59]:
                self.enterOuterAlt(localctx, 18)
                self.state = 633
                self.match(GeoAnQuParser.T__59)
                self.state = 634
                self.match(GeoAnQuParser.DIGIT)
                self.state = 635
                self.match(GeoAnQuParser.ML)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def grid(self):
            return self.getTypedRuleContext(GeoAnQuParser.GridContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def distBand(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistBandContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_support

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupport" ):
                listener.enterSupport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupport" ):
                listener.exitSupport(self)




    def support(self):

        localctx = GeoAnQuParser.SupportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_support)
        try:
            self.state = 645
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 638
                self.grid()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 639
                self.coreC()
                self.state = 642
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
                if la_ == 1:
                    self.state = 640
                    self.match(GeoAnQuParser.T__10)
                    self.state = 641
                    self.coreC()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 644
                self.distBand()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtent" ):
                listener.enterExtent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtent" ):
                listener.exitExtent(self)




    def extent(self):

        localctx = GeoAnQuParser.ExtentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_extent)
        try:
            self.state = 650
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__42]:
                self.enterOuterAlt(localctx, 1)
                self.state = 647
                self.match(GeoAnQuParser.T__42)
                self.state = 648
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__60]:
                self.enterOuterAlt(localctx, 2)
                self.state = 649
                self.match(GeoAnQuParser.T__60)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemExContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_temEx

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemEx" ):
                listener.enterTemEx(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemEx" ):
                listener.exitTemEx(self)




    def temEx(self):

        localctx = GeoAnQuParser.TemExContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_temEx)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 652
            self.match(GeoAnQuParser.T__33)
            self.state = 653
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





